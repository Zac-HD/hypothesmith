"""Hypothesis strategies for generating Python source code, somewhat like CSmith."""

import urllib.request
from pathlib import Path

import hypothesis.strategies as st
from hypothesis import assume
from hypothesis.extra.lark import LarkStrategy
from lark import Lark
from lark.indenter import Indenter

URL = "https://raw.githubusercontent.com/lark-parser/lark/master/examples/python3.lark"
fname = Path(__file__).with_name(URL.split("/")[-1])

if fname.exists():
    with open(fname) as f:
        lark_grammar = f.read()
else:  # pragma: no cover
    # To update the grammar definition, delete the file and execute this.
    with urllib.request.urlopen(URL) as handle:
        lark_grammar = handle.read().decode()
    with open(fname, "w") as f:
        f.write(lark_grammar)


class PythonIndenter(Indenter):
    # https://github.com/lark-parser/lark/blob/master/examples/python_parser.py
    NL_type = "_NEWLINE"
    OPEN_PAREN_types = ["LPAR", "LSQB", "LBRACE"]
    CLOSE_PAREN_types = ["RPAR", "RSQB", "RBRACE"]
    INDENT_type = "_INDENT"
    DEDENT_type = "_DEDENT"
    tab_len = 4


def utf8_encodable(terminal: str) -> bool:
    try:
        terminal.encode()
        return True
    except UnicodeEncodeError:
        return False


class GrammarStrategy(LarkStrategy):
    # TODO: upstream pull request to support custom strategies for terminals.
    # https://github.com/HypothesisWorks/hypothesis/compare/master...Zac-HD:lark-python
    #
    # Note however that we may want to keep this anyway, to filter out
    # any non-utf8-encodable strings that match the terminal regexen.

    def __init__(
        self, grammar: Lark, start: str = None, explicit_strategies: dict = None
    ):
        LarkStrategy.__init__(self, grammar, start=start)  # type: ignore

        terminals, _, _ = grammar.grammar.compile(start)
        self.terminal_strategies = {
            t.name: st.from_regex(t.pattern.to_regexp(), True).filter(utf8_encodable)
            for t in terminals
        }
        self.terminal_strategies.update(explicit_strategies or {})


def fixup(source_code: str) -> str:
    """Strip trailing whitespace and backslash if any and add ending newline."""
    assume("\0" not in source_code)
    source_code = source_code.rstrip(" \t\n\r\v\f\\") + "\n"
    try:
        compile(source=source_code, filename="<string>", mode="exec")
    except (SyntaxError):
        # Python's grammar doesn't actually fully describe the behaviour of the
        # CPython parser and AST-post-processor, so we just filter out errors.
        assume(False)
    return source_code


def from_grammar(start: str = "file_input") -> st.SearchStrategy[str]:
    """Generate syntactically-valid Python source code based on the grammar.

    Valid values for ``start`` are ``"single_input"``, ``"file_input"``, or
    ``"eval_input"``; respectively a single interactive statement, a module or
    sequence of commands read from a file, and input for the eval() function.

    .. warning::
        DO NOT EXECUTE CODE GENERATED BY THIS STRATEGY.

        It could do literally anything that running Python code is able to do,
        including changing, deleting, or uploading important data.  Arbitrary
        code can be useful, but "arbitrary code execution" can be very, very bad.
    """
    assert start in {"single_input", "file_input", "eval_input"}
    grammar = Lark(lark_grammar, parser="lalr", postlex=PythonIndenter(), start=start)
    explicit_strategies = dict(
        _INDENT=st.just(" " * 4),
        _DEDENT=st.just(""),
        NAME=st.from_regex(r"[a-z_A-Z]+", fullmatch=True).filter(str.isidentifier),
    )
    return GrammarStrategy(grammar, start, explicit_strategies).map(fixup)
